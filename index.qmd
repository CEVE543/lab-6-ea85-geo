---
title: "CEVE 543 Fall 2025 Lab 6: Julia Climate Data Tools"
subtitle: "YAXArrays.jl, NetCDF.jl, exploring CMIP6 data structure"
author: CEVE 543 Fall 2025
date: "2025-10-17"
type: "lab"
module: 2
week: 9
objectives:
  - "Load and explore climate model output using YAXArrays.jl"
  - "Work with NetCDF files and understand CMIP6 data structure"
  - "Extract and visualize climate model data for specific locations and time periods"
  - "Establish foundation for downscaling and bias correction exercises"
ps_connection: "Establishes data handling skills needed for all PS2 problems working with climate model output"

engine: julia

format:
  html:
    toc: true
    toc-depth: 2
    code-block-bg: "#f8f8f8"
    code-block-border-left: "#e1e4e5"
    theme: simplex
    number-sections: true
    fig-format: svg
  typst:
    fontsize: 11pt
    margin: 
      x: 1in
      y: 1in
    number-sections: true
    fig-format: svg

execute: 
  cache: true
  freeze: auto

# Code formatting options
code-overflow: wrap
code-line-numbers: false
code-block-font-size: "0.85em"
---

```{julia}
#| output: false
using Pkg
lab_dir = dirname(@__FILE__)
Pkg.activate(lab_dir)
# Pkg.instantiate() # uncomment this the first time you run the lab to install packages, then comment it back
import GeoMakie: GeoAxis, surface!, translate!, coastlines
using GeoMakie
using YAXArrays
using YAXArrays: YAXArrays as YAX
using NetCDF
using Downloads: download
using CFTime
using IntervalSets
using Zarr, YAXArrays, Dates
using DimensionalData
using CairoMakie, CairoMakie
using CairoMakie.GeometryBasics
using Statistics
import GeoMakie: GeoAxis



a = YAXArray(rand(2,3))
#a2[Variables=At("temperature"), time=1].data

 ############################################################################

path = download("https://archive.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc", "example.nc")

fname = joinpath(pwd(), "example.nc") 
if !isfile(fname); download("https://archive.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc", fname); end

ds = open_dataset(path)
tos = ds.tos
tos[lon = 1, lat = 1]
tos[lon = At(1), lat = At(-79.5)]
##
time1 = DateTime360Day(2001,01,16)
tos[time = At(time1)]
tos[lon = 1:10, lat = 1:10]
tos[lon = At(1.0:2:19), lat = At(-79.5:1:-70.5)]
tos[lon = At(1:10; atol = 1)]
tos[lon = 90 .. 180]
tos[lon = OpenInterval(90, 180)]
tos[lon = ClosedInterval(90, 180)]
tos[lon =Interval{:open,:closed}(90,180)]
tos[lon =Interval{:closed,:open}(90,180)]
lookup(tos, :lon)
tos.lon.val
 
##################################################### Plotting 
store ="gs://cmip6/CMIP6/ScenarioMIP/DKRZ/MPI-ESM1-2-HR/ssp585/r1i1p1f1/3hr/tas/gn/v20190710/"
g = open_dataset(zopen(store, consolidated=true))
c = g["tas"];
ct1_slice = c[time = Near(Date("2015-01-01"))];
lon_d = lookup(ct1_slice, :lon)
lat_d = lookup(ct1_slice, :lat)
data_d = ct1_slice.data[:,:];

##Heatmap
CairoMakie.activate!()
fig, ax, plt = heatmap(ct1_slice; colormap = :seaborn_icefire_gradient,
    axis = (; aspect=DataAspect()),
    figure = (; size = (1200,600), fontsize=24))

δlon = (lon_d[2] - lon_d[1])/2
nlon = lon_d .- 180 .+ δlon
ndata = circshift(data_d, (192,1))

##Wintri Projection
#fig = Figure(;size=(1200,600))
#ax = GeoAxis(fig[1,1])
#surface!(ax, nlon, lat_d, ndata; colormap = :seaborn_icefire_gradient, shading=false)
#cl=lines!(ax, GeoMakie.coastlines(), color = :white, linewidth=0.85)
#translate!(cl, 0, 0, 1000)
#display(fig)

##Moll Projection 
#fig = Figure(; size=(1200,600))
#ax = GeoAxis(fig[1,1]; dest = "+proj=moll")
#surface!(ax, nlon, lat_d, ndata; colormap = :seaborn_icefire_gradient, shading=false)
#cl=lines!(ax, GeoMakie.coastlines(), color = :white, linewidth=0.85)
#translate!(cl, 0, 0, 1000)
#display(fig)

##3D Sphere Plot 

#ss = replace(ndata, missing =>NaN)
#phere = uv_normal_mesh(Tesselation(Sphere(Point3f(0), 1), 128))

#fig = Figure(backgroundcolor=:grey25, size=(500,500))
#ax = LScene(fig[1,1], show_axis=false)
#mesh!(ax, sphere; color = ds'[end:-1:1,:], shading=false,
#    colormap = :seaborn_icefire_gradient)
#zoom!(ax.scene, cameracontrols(ax.scene), 0.5)
#rotate!(ax.scene, 2.5)
#display(fig)


##my turn  
# - Select a single rectangular region. Compute the average `tas` over that region (if you're fancy, weight by the cosine of latitude to account for the decreasing area of grid cells towards the poles, as shown in [this xarray example](https://docs.xarray.dev/en/latest/examples/area_weighted_temperature.html)) and plot the time series of `tas` for that region.
 # - Using that time series, find the hottest and coldest 3-hourly periods in the entire dataset for that region. For those two time periods, plot the spatial distribution of `tas` over the entire globe using a map projection of your choice.

################################################################
## Time Series
## Chosen Region: Gulf of Mexico
################################################################

using Plots
using TimeSeries
using Dates
using GeoMakie


##subset gulf of mexico lat/lon
tas_val_STX = tos[lon = Between(265, 275), lat = Between(20, 30)]
avg_tas_STX = mean(tas_val_STX; dims=(Dim{:lat}(), Dim{:lon}()))
avg_tas_STX = dropdims(avg_tas_STX; dims=(Dim{:lat}(), Dim{:lon}()))

A = collect(tas_val_STX)            
##1st dimension is lat, second dimension is lon, third is time    
y = [ mean(skipmissing(vec(A[:, :, t]))) for t in axes(A, 3) ]

t_raw = collect(tas_val_STX.time) 
#make dates standard
t_raw_ = [DateTime(year(t), month(t), day(t)) for t in collect(t_raw)]


 Plots.plot(t_raw_, y; lw=2, legend=false,
           xlabel="Time",
           ylabel="Sea surface temperature (K)",
           title="Time Series of TAS in Gulf of Mexico ", 
           xrotation = 45,
          xticks = (t_raw_, Dates.format.(t_raw_, "yyyy-mm"))
       )

################################################################
## Heat maps 
################################################################

##Dryest three months
ct1_slice_ = tos[time = Between(DateTime360Day(2002, 2, 16), DateTime360Day(2002, 4, 16))]
ct1_slice_ = mean(ct1_slice_; dims=(Dim{:time}()))
ct1_slice_=dropdims(ct1_slice_; dims=Dim{:time}())

lon_d_ = lookup(ct1_slice_, :lon)
lat_d_ = lookup(ct1_slice_, :lat)
data_d_ = ct1_slice_.data[:,:]

#Wettest three months
ct1_slice__ = tos[time = Between(DateTime360Day(2002, 7, 16), DateTime360Day(2002, 9, 16))]
ct1_slice__ = mean(ct1_slice__; dims=(Dim{:time}()))
ct1_slice__=dropdims(ct1_slice__; dims=Dim{:time}())

lon_d__ = lookup(ct1_slice__, :lon)
lat_d__ = lookup(ct1_slice__, :lat)
data_d__ = ct1_slice__.data[:,:]

##Heatmap (Dryest 3 months)
import GeoMakie: surface!, translate!
using DimensionalData

δlon_ = (lon_d_[2] - lon_d_[1])/2
nlon_ = lon_d_ .- 180 .+ δlon_
ndata_ = circshift(data_d_, (192,1))
fig = Figure(;size=(1200,600))
ax = GeoAxis(fig[1,1])
surface!(ax, nlon_, lat_d_, ndata_; colormap = :seaborn_icefire_gradient, shading=false)
display(fig)


## "Heatmap (Wettest 3 Months)"
import GeoMakie: surface!
using DimensionalData
import GeoMakie: surface!, translate!
using DimensionalData

δlon__ = (lon_d__[2] - lon_d__[1])/2
nlon__ = lon_d__ .- 180 .+ δlon__
ndata__ = circshift(data_d__, (192,1))
fig = Figure(;size=(1200,600))
ax = GeoAxis(fig[1,1])
surface!(ax, nlon__, lat_d__, ndata__; colormap = :seaborn_icefire_gradient, shading=false)
display(fig)




```



